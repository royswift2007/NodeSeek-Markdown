/**********************
 * åŸºç¡€å·¥å…·
 **********************/

function isProbablyUrl(u) {
  try {
    const url = new URL(u);
    return url.protocol === "http:" || url.protocol === "https:";
  } catch {
    return false;
  }
}

function clampLen(s, max) {
  s = String(s || "");
  return s.length > max ? s.slice(0, max) : s;
}

function mdEscapeInline(s) {
  return String(s || "").replace(/`/g, "\\`");
}

function mdEscapeAlt(s) {
  return mdEscapeInline(s)
    .replace(/\]/g, "\\]")
    .replace(/\r?\n+/g, " ")
    .trim();
}

/**********************
 * æ–‡æœ¬æ¸…æ´— / åˆ†å¥ / åˆ†æ®µï¼ˆä¿®æ­£ç‰ˆï¼‰
 **********************/

function normalizeText(raw) {
  let t = String(raw || "").replace(/\r\n/g, "\n");
  t = t
    .split("\n")
    .map((line) => line.replace(/[ \t]+$/g, ""))
    .join("\n");
  t = t.replace(/[ \t]{2,}/g, " ");
  return t.trim();
}

function splitSentences(raw) {
  // å¯¹ä¸­æ–‡æ›´å‹å¥½ï¼Œé¿å…è¯¯åˆ‡ URL/ç‰ˆæœ¬å·/å°æ•°ç‚¹
  const text = String(raw || "").trim();
  if (!text) return [];

  const out = [];
  let buf = "";

  const isUrlContext = (s) => {
    return /(https?:\/\/|www\.)/i.test(s) || /[a-z0-9-]+\.[a-z]{2,}/i.test(s);
  };

  const isNumberDot = (p, n) => /[0-9]/.test(p || "") && /[0-9]/.test(n || "");

  const chars = [...text];
  for (let i = 0; i < chars.length; i++) {
    const ch = chars[i];
    const prev = chars[i - 1];
    const next = chars[i + 1];

    buf += ch;

    // çœç•¥å·ï¼š... æˆ– â€¦â€¦
    if (ch === "." && chars[i + 1] === "." && chars[i + 2] === ".") {
      buf += "..";
      i += 2;
      out.push(buf.trim());
      buf = "";
      continue;
    }
    if (ch === "â€¦" && chars[i + 1] === "â€¦") {
      buf += "â€¦";
      i += 1;
      out.push(buf.trim());
      buf = "";
      continue;
    }

    // å¼ºå¥æœ«
    if (ch === "ã€‚" || ch === "ï¼" || ch === "ï¼Ÿ" || ch === "!" || ch === "?") {
      out.push(buf.trim());
      buf = "";
      continue;
    }

    // è‹±æ–‡å¥å·ï¼šé¿å…åœ¨ 1.2 / v1.2.3 / example.com åˆ‡åˆ†
    if (ch === ".") {
      if (isNumberDot(prev, next)) continue;
      if (isUrlContext(buf)) continue;
      if (/[a-z]/i.test(next || "")) continue;
      out.push(buf.trim());
      buf = "";
      continue;
    }

    // åˆ†å·ä½œä¸ºå¼±å¥æœ«
    if (ch === "ï¼›" || ch === ";") {
      out.push(buf.trim());
      buf = "";
      continue;
    }
  }

  if (buf.trim()) out.push(buf.trim());
  return out.filter(Boolean);
}

function formatIntoParagraphs(raw, sentencesPerPara) {
  const t = normalizeText(raw);
  if (!t) return "";

  // è‹¥å·²æœ‰ç©ºè¡Œ â†’ å°Šé‡ç”¨æˆ·æ®µè½ï¼›æ®µå†…åˆå¹¶ç¡¬æ¢è¡Œ
  if (/\n\s*\n/.test(t)) {
    return t
      .split(/\n\s*\n+/)
      .map((p) => p.replace(/\n+/g, " ").trim())
      .filter(Boolean)
      .join("\n\n");
  }

  // æ— ç©ºè¡Œ â†’ è‡ªåŠ¨åˆ†å¥å¹¶ç»„æ®µ
  const sents = splitSentences(t);

  // å…œåº•ï¼šé€—å·å¼±åˆ‡ï¼Œé¿å…æ•´ç¯‡â€œä¸€å¨â€
  if (sents.length <= 1 && t.length > 120) {
    const weak = t.split(/[ï¼Œ,]/).map((x) => x.trim()).filter(Boolean);
    const out = [];
    for (let i = 0; i < weak.length; i += 3) {
      out.push(weak.slice(i, i + 3).join("ï¼Œ"));
    }
    return out.join("\n\n");
  }

  const n = Math.max(1, Math.min(5, parseInt(sentencesPerPara, 10) || 2));
  const paras = [];
  for (let i = 0; i < sents.length; i += n) {
    paras.push(sents.slice(i, i + n).join(" "));
  }
  return paras.join("\n\n");
}

/**********************
 * åˆ—è¡¨ / å°æ ‡é¢˜
 **********************/

function toBulletList(raw, mode, sentencesPerItem) {
  // mode: "lines" | "sentences"
  const t = normalizeText(raw);
  if (!t) return "";

  if (mode === "lines") {
    const items = t
      .split("\n")
      .map((x) => x.trim())
      .filter(Boolean)
      .map((x) => x.replace(/^[-*â€¢]\s+/, "").replace(/^\d+[\.\)]\s+/, ""));
    return items.map((x) => "- " + x).join("\n");
  }

  const sents = splitSentences(t);
  const n = Math.max(1, Math.min(5, parseInt(sentencesPerItem, 10) || 1));
  const items = [];
  for (let i = 0; i < sents.length; i += n) {
    items.push(sents.slice(i, i + n).join(" "));
  }
  return items.map((x) => "- " + x).join("\n");
}

function parseSections(raw) {
  // è¯†åˆ«ï¼š
  // 1) 1. æ ‡é¢˜ / 1) æ ‡é¢˜
  // 2) æ ‡é¢˜ï¼šå†…å®¹
  // âœ… ä¿®å¤ï¼šé‡åˆ° https:// è¿™ç§ä¸è¦æŠŠ https: å½“æˆæ ‡é¢˜
  const t = normalizeText(raw);
  if (!t) return [];

  const lines = t.split("\n").map((x) => x.trim()).filter(Boolean);

  const hasNumHead = lines.some((l) => /^\d+[\.\)]\s+/.test(l));
  const sections = [];

  if (hasNumHead) {
    let current = null;
    for (const line of lines) {
      const m = line.match(/^(\d+)[\.\)]\s+(.*)$/);
      if (m) {
        if (current) sections.push(current);
        current = { title: m[2].trim(), body: "" };
      } else if (current) {
        current.body += (current.body ? "\n" : "") + line;
      } else {
        sections.push({ title: "", body: line });
      }
    }
    if (current) sections.push(current);
    return sections;
  }

  let current = { title: "", body: "" };

  for (const line of lines) {
    // âœ… å…³é”®ï¼šåŒ…å« "://" çš„ç›´æ¥è§†ä¸ºå†…å®¹è¡Œ
    if (line.includes("://")) {
      current.body += (current.body ? "\n" : "") + line;
      continue;
    }

    const m = line.match(/^(.{1,24})[ï¼š:]\s*(.*)$/);
    if (m) {
      // å†ä¿é™©ï¼šé¿å… http/https/ftp/file: //xxx è¢«å½“æ ‡é¢˜
      const head = (m[1] || "").trim().toLowerCase();
      const tail = (m[2] || "").trim();
      const looksLikeScheme =
        (head === "http" || head === "https" || head === "ftp" || head === "file") && tail.startsWith("//");
      if (looksLikeScheme) {
        current.body += (current.body ? "\n" : "") + line;
        continue;
      }

      if (current.title || current.body) sections.push(current);
      current = { title: m[1].trim(), body: m[2].trim() };
    } else {
      current.body += (current.body ? "\n" : "") + line;
    }
  }

  if (current.title || current.body) sections.push(current);
  return sections;
}

function renderSections(sections, bodyStyle, paraN, listMode, listN) {
  // bodyStyle: "paragraphs" | "list"
  const out = [];
  for (const s of sections) {
    if (s.title) out.push("### " + mdEscapeInline(s.title));
    const body = s.body || "";
    if (bodyStyle === "list") {
      out.push(toBulletList(body, listMode, listN));
    } else {
      out.push(formatIntoParagraphs(body, paraN));
    }
    out.push("");
  }
  return out.join("\n").trim();
}

/**********************
 * âœ… å¼ºè°ƒæ ‡è®°ï¼ˆæ›¿ä»£é¢œè‰²ï¼‰åº”ç”¨åˆ°æ ¼å¼åŒ–ç»“æœ
 * è§„åˆ™ï¼šä¸æ”¹å°æ ‡é¢˜ï¼ˆ###ï¼‰ï¼Œå¯¹æ®µè½é¦–è¡Œ/åˆ—è¡¨é¡¹åŠ  emoji
 **********************/

function applyEmojiToFormattedMarkdown(formatted, emoji) {
  const em = String(emoji || "").trim();
  if (!em) return formatted;

  const lines = String(formatted || "").split("\n");
  let startOfBlock = true;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (!line.trim()) {
      startOfBlock = true;
      continue;
    }

    // ä¸åŠ¨å°æ ‡é¢˜
    if (line.startsWith("### ")) {
      startOfBlock = true; // æ ‡é¢˜åä¸‹ä¸€è¡Œä¹Ÿè§†ä½œå—èµ·å§‹
      continue;
    }

    // åˆ—è¡¨é¡¹ï¼š- item â†’ - ğŸŸ¢ item
    if (line.startsWith("- ")) {
      const rest = line.slice(2).trim();
      // é˜²é‡å¤
      if (!rest.startsWith(em + " ")) {
        lines[i] = "- " + em + " " + rest;
      }
      startOfBlock = false;
      continue;
    }

    // æ®µè½ï¼šåªåœ¨æ®µè½é¦–è¡ŒåŠ 
    if (startOfBlock) {
      if (!line.startsWith(em + " ")) {
        lines[i] = em + " " + line;
      }
      startOfBlock = false;
    }
  }

  return lines.join("\n");
}

/**********************
 * Markdown è¾“å‡ºï¼ˆå›¾ç‰‡ / æ–‡å­—ï¼‰
 **********************/

function makeMdText(text, opt) {
  let t = String(text || "").trim();
  if (!t) return "";

  t = mdEscapeInline(t);

  if (opt.strike) t = "~~" + t + "~~";
  if (opt.bold) t = "**" + t + "**";
  if (opt.prefixEmoji) t = opt.prefixEmoji + " " + t;

  if (opt.quote) {
    t = t
      .split("\n")
      .map((line) => (line.trim() ? "> " + line : ">"))
      .join("\n");
  }

  return t;
}

function makeMdImage(url, alt) {
  const a = mdEscapeAlt(alt || "image");
  return "![" + (a || "image") + "](" + url + ")";
}

/**********************
 * é¡µé¢ï¼ˆæ–‡æœ¬æ ¼å¼åŒ–é¢æ¿åŠ å…¥å¼ºè°ƒæ ‡è®°ï¼‰
 * æ³¨æ„ï¼šè„šæœ¬é‡Œä¸ä½¿ç”¨åå¼•å·ï¼Œé¿å…åµŒå¥—å¯¼è‡´ SyntaxError
 **********************/

const PAGE = () => `<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NodeSeek Markdown å·¥å…·</title>
<style>
  :root{
    --bg:#0f172a;--panel:#111827;--border:#1f2937;--input:#020617;
    --text:#e5e7eb;--muted:#9ca3af;--accent:#38bdf8;--radius:12px;
  }
  *{box-sizing:border-box}
  body{
    margin:0;background:var(--bg);color:var(--text);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    line-height:1.55;
  }
  .wrap{max-width:980px;margin:0 auto;padding:40px 16px 80px}
  h1{margin:0 0 6px;font-size:28px;letter-spacing:.2px}
  .sub{color:var(--muted);font-size:14px}
  .panel{
    background:var(--panel);border:1px solid var(--border);
    border-radius:var(--radius);padding:20px;margin-top:14px;
  }
  .titleRow{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:12px}
  .titleRow h2{margin:0;font-size:16px;color:rgba(229,231,235,.95)}
  .tag{font-size:12px;color:var(--muted)}
  label{display:block;font-size:13px;color:var(--muted);margin:10px 0 6px}
  input,textarea,select,button,pre{
    width:100%;background:var(--input);color:var(--text);
    border:1px solid var(--border);border-radius:10px;
    padding:10px 12px;font-size:14px;
  }
  textarea{min-height:160px;resize:vertical}
  input:focus,textarea:focus,select:focus{outline:none;border-color:var(--accent)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:14px}
  .btn{
    margin-top:12px;background:var(--accent);color:#020617;
    font-weight:700;border:none;cursor:pointer;
    transition:transform .08s ease,opacity .08s;
  }
  .btn:hover{opacity:.92}
  .btn:active{transform:translateY(1px)}
  .result{display:none;margin-top:14px}
  pre{
    background:#020617;white-space:pre-wrap;word-break:break-word;
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:13px;
  }
  .actions{display:flex;gap:10px;margin-top:10px;flex-wrap:wrap}
  .actions button{width:auto;cursor:pointer}
  .actions button:hover{border-color:var(--accent)}
  img.preview{margin-top:14px;max-width:100%;border-radius:10px;border:1px solid var(--border)}
  .hint{margin-top:6px;font-size:12px;color:var(--muted)}
  footer{margin-top:28px;text-align:center;color:var(--muted);font-size:12px}
  .toast{
    position:fixed;right:16px;bottom:16px;background:#020617;border:1px solid var(--border);
    padding:10px 14px;border-radius:10px;font-size:13px;opacity:0;transform:translateY(10px);
    transition:all .2s ease;pointer-events:none;
  }
  .toast.show{opacity:1;transform:translateY(0)}
</style>
</head>
<body>
  <div class="wrap">
    <h1>NodeSeek Markdown å·¥å…·</h1>
    <div class="sub">çº¯ Markdown Â· ä¸ä½¿ç”¨ HTML Â· å›¾ç‰‡ä»£ç  + æ–‡æœ¬æ®µè½/åˆ—è¡¨/å°æ ‡é¢˜</div>
    <div class="sub">ğŸ”´ Cloudflare Workers Freeæ¯å¤©åªæœ‰10ä¸‡è¯·æ±‚ . èŠ‚çœç‚¹ç”¨å“ˆ</div>
    
    <div class="panel">
      <div class="titleRow">
        <h2>å›¾ç‰‡ â†’ Markdown</h2>
        <div class="tag">/api/convert</div>
      </div>

      <label>å›¾ç‰‡ URLï¼ˆå¯ç©ºï¼‰</label>
      <input id="url" placeholder="https://example.com/image.png" />

      <div class="grid">
        <div>
          <label>å›¾ç‰‡ altï¼ˆå¯ç©ºï¼‰</label>
          <input id="alt" placeholder="æµ‹é€Ÿæˆªå›¾ / æ–¹æ¡ˆç¤ºæ„å›¾" />
        </div>
        <div>
          <label>å¼ºè°ƒæ ‡è®°ï¼ˆæ›¿ä»£é¢œè‰²ï¼‰</label>
          <select id="emoji">
            <option value="">æ— </option>
            <option value="ğŸŸ¢">ğŸŸ¢ æ¨è / æ­£å‘</option>
            <option value="ğŸŸ¡">ğŸŸ¡ æ³¨æ„ / æç¤º</option>
            <option value="ğŸ”´">ğŸ”´ è­¦å‘Š / é¿é›·</option>
            <option value="âš¡">âš¡ é‡ç‚¹</option>
          </select>
        </div>
      </div>

      <label>è¯´æ˜æ–‡å­—ï¼ˆå¯é€‰ï¼Œå¯ç²˜è´´æ®µè½ï¼‰</label>
      <textarea id="text" placeholder="ä½ å¯ä»¥å…ˆåœ¨ä¸‹é¢â€œæ–‡æœ¬æ ¼å¼åŒ–â€æ•´ç†å¥½æ®µè½ï¼Œå†ç²˜è´´åˆ°è¿™é‡Œä¸€èµ·è¾“å‡ºã€‚"></textarea>

      <div class="grid3">
        <div>
          <label>åŠ ç²—</label>
          <select id="bold">
            <option value="no">å¦</option>
            <option value="yes">æ˜¯</option>
          </select>
        </div>
        <div>
          <label>åˆ é™¤çº¿</label>
          <select id="strike">
            <option value="no">å¦</option>
            <option value="yes">æ˜¯</option>
          </select>
        </div>
        <div>
          <label>å¼•ç”¨å—</label>
          <select id="quote">
            <option value="no">å¦</option>
            <option value="yes">æ˜¯ï¼ˆæ¯è¡ŒåŠ  >ï¼‰</option>
          </select>
        </div>
      </div>

      <button class="btn" id="btnGen">ç”Ÿæˆ Markdown</button>
      <div class="hint">è¯´æ˜ï¼šNodeSeek ä¸æ”¯æŒ HTML æ—¶ï¼Œæ— æ³•å˜è‰²/æ§å¤§å°/å¯¹é½ï¼›è¿™é‡Œç”¨ emoji æ›¿ä»£é¢œè‰²ã€‚å›¾ç‰‡ URL ç•™ç©ºåˆ™åªè¾“å‡ºæ–‡å­—ã€‚</div>

      <div class="result" id="genResult">
        <pre id="genOut"></pre>
        <div class="actions">
          <button id="genCopy">å¤åˆ¶</button>
          <button id="genClear">æ¸…ç©º</button>
        </div>
        <img class="preview" id="preview" style="display:none" />
      </div>
    </div>

    <div class="panel">
      <div class="titleRow">
        <h2>æ–‡æœ¬æ ¼å¼åŒ–ï¼šæ®µè½ / åˆ—è¡¨ / å°æ ‡é¢˜</h2>
        <div class="tag">/api/format</div>
      </div>

      <label>ç²˜è´´åŸå§‹æ–‡å­—</label>
      <textarea id="raw" placeholder="æ”¯æŒè¯†åˆ«ï¼š&#10;1) æ ‡é¢˜ / 1. æ ‡é¢˜&#10;ä»¥åŠï¼šæ ‡é¢˜ï¼šå†…å®¹&#10;è‹¥åŸæ–‡æœ‰ç©ºè¡Œï¼Œä¼šä¿ç•™æ®µè½ï¼›å¦åˆ™è‡ªåŠ¨æŒ‰å¥æœ«æ ‡ç‚¹åˆ†å¥å†ç»„æ®µã€‚"></textarea>

      <div class="grid">
        <div>
          <label>æ ¼å¼åŒ–æ¨¡å¼</label>
          <select id="fmtMode">
            <option value="paragraphs">æ®µè½</option>
            <option value="list_lines">åˆ—è¡¨ï¼ˆæŒ‰è¡Œï¼‰</option>
            <option value="list_sentences">åˆ—è¡¨ï¼ˆæŒ‰å¥ï¼‰</option>
            <option value="h_paragraphs">å°æ ‡é¢˜ + æ®µè½</option>
            <option value="h_list">å°æ ‡é¢˜ + åˆ—è¡¨</option>
          </select>
        </div>
        <div>
          <label>è¾“å‡ºä¸ºå¼•ç”¨å—</label>
          <select id="fmtQuote">
            <option value="no">å¦</option>
            <option value="yes">æ˜¯ï¼ˆæ¯è¡ŒåŠ  >ï¼‰</option>
          </select>
        </div>
      </div>

      <div class="grid3">
        <div>
          <label>æ®µè½ï¼šæ¯æ®µå¥å­æ•°</label>
          <select id="paraN">
            <option value="1">1</option>
            <option value="2" selected>2ï¼ˆæ¨èï¼‰</option>
            <option value="3">3</option>
          </select>
        </div>
        <div>
          <label>åˆ—è¡¨ï¼ˆæŒ‰å¥ï¼‰ï¼šæ¯æ¡å¥å­æ•°</label>
          <select id="listN">
            <option value="1" selected>1</option>
            <option value="2">2</option>
            <option value="3">3</option>
          </select>
        </div>
        <div>
          <label>æ ‡é¢˜å—ä¸‹ï¼šåˆ—è¡¨æ–¹å¼</label>
          <select id="listMode">
            <option value="lines" selected>æŒ‰è¡Œ</option>
            <option value="sentences">æŒ‰å¥</option>
          </select>
        </div>
      </div>

      <div class="grid">
        <div>
          <label>å¼ºè°ƒæ ‡è®°ï¼ˆæ›¿ä»£é¢œè‰²ï¼‰</label>
          <select id="fmtEmoji">
            <option value="">æ— </option>
            <option value="ğŸŸ¢">ğŸŸ¢ æ¨è / æ­£å‘</option>
            <option value="ğŸŸ¡">ğŸŸ¡ æ³¨æ„ / æç¤º</option>
            <option value="ğŸ”´">ğŸ”´ è­¦å‘Š / é¿é›·</option>
            <option value="âš¡">âš¡ é‡ç‚¹</option>
          </select>
        </div>
        <div></div>
      </div>

      <button class="btn" id="btnFmt">æ ¼å¼åŒ–è¾“å‡º</button>

      <div class="result" id="fmtResult">
        <pre id="fmtOut"></pre>
        <div class="actions">
          <button id="fmtCopy">å¤åˆ¶</button>
          <button id="fmtClear">æ¸…ç©º</button>
        </div>
      </div>
    </div>

    <footer>æœ¬å·¥å…·ä»…ç”Ÿæˆ Markdown æ–‡æœ¬ï¼Œä¸å­˜å‚¨ã€ä¸ä»£ç†ã€ä¸åˆ†å‘å›¾ç‰‡èµ„æº</footer>
  </div>

  <div class="toast" id="toast"></div>

<script>
  function $(id){ return document.getElementById(id); }
  var toast = $("toast");
  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    setTimeout(function(){ toast.classList.remove("show"); }, 1800);
  }

  $("btnGen").onclick = async function(){
    var payload = {
      url: $("url").value.trim(),
      alt: $("alt").value.trim(),
      text: $("text").value,
      emoji: $("emoji").value,
      bold: $("bold").value === "yes",
      strike: $("strike").value === "yes",
      quote: $("quote").value === "yes"
    };

    var res = await fetch("/api/convert", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(payload)
    });

    var data = await res.json();
    if (!res.ok) { showToast(data.error || "ç”Ÿæˆå¤±è´¥"); return; }

    $("genOut").textContent = data.output || "";
    $("genResult").style.display = "block";

    if (data.url) {
      $("preview").src = data.url;
      $("preview").style.display = "block";
    } else {
      $("preview").style.display = "none";
    }

    showToast("å·²ç”Ÿæˆ Markdown");
  };

  $("genCopy").onclick = async function(){
    try { await navigator.clipboard.writeText($("genOut").textContent); showToast("å·²å¤åˆ¶"); }
    catch(e){ showToast("å¤åˆ¶å¤±è´¥ï¼ˆæµè§ˆå™¨é™åˆ¶ï¼‰"); }
  };

  $("genClear").onclick = function(){
    $("url").value = "";
    $("alt").value = "";
    $("text").value = "";
    $("emoji").value = "";
    $("bold").value = "no";
    $("strike").value = "no";
    $("quote").value = "no";
    $("genResult").style.display = "none";
    $("preview").style.display = "none";
    showToast("å·²æ¸…ç©º");
  };

  $("btnFmt").onclick = async function(){
    var payload = {
      raw: $("raw").value,
      fmtMode: $("fmtMode").value,
      paraN: $("paraN").value,
      listN: $("listN").value,
      listMode: $("listMode").value,
      emoji: $("fmtEmoji").value,
      quote: $("fmtQuote").value === "yes"
    };

    var res = await fetch("/api/format", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(payload)
    });

    var data = await res.json();
    if (!res.ok) { showToast(data.error || "æ ¼å¼åŒ–å¤±è´¥"); return; }

    $("fmtOut").textContent = data.formatted || "";
    $("fmtResult").style.display = "block";
    showToast("å·²æ ¼å¼åŒ–");
  };

  $("fmtCopy").onclick = async function(){
    try { await navigator.clipboard.writeText($("fmtOut").textContent); showToast("å·²å¤åˆ¶"); }
    catch(e){ showToast("å¤åˆ¶å¤±è´¥ï¼ˆæµè§ˆå™¨é™åˆ¶ï¼‰"); }
  };

  $("fmtClear").onclick = function(){
    $("raw").value = "";
    $("fmtResult").style.display = "none";
    showToast("å·²æ¸…ç©º");
  };
</script>
</body>
</html>`;

/**********************
 * Worker è·¯ç”±
 **********************/

addEventListener("fetch", (event) => {
  event.respondWith(handle(event.request));
});

async function handle(request) {
  const url = new URL(request.url);

  // é¦–é¡µ
  if (request.method === "GET" && url.pathname === "/") {
    return new Response(PAGE(), {
      headers: { "content-type": "text/html; charset=utf-8" },
    });
  }

  // å›¾ç‰‡ â†’ Markdown
  if (url.pathname === "/api/convert" && request.method === "POST") {
    let body;
    try {
      body = await request.json();
    } catch {
      return json({ error: "è¯·æ±‚ä½“å¿…é¡»æ˜¯ JSON" }, 400);
    }

    // âœ… å…è®¸å›¾ç‰‡ URL ä¸ºç©ºï¼šä¸ºç©ºæ—¶ä»…è¾“å‡ºæ–‡å­—
    const imgUrl = String(body?.url || "").trim();
    const alt = clampLen(String(body?.alt || "").trim(), 200);
    const text = clampLen(String(body?.text || ""), 8000);

    const emoji = clampLen(String(body?.emoji || "").trim(), 4);
    const bold = !!body?.bold;
    const strike = !!body?.strike;
    const quote = !!body?.quote;

    const textPart = makeMdText(text, {
      bold,
      strike,
      prefixEmoji: emoji,
      quote,
    });

    // ä¸¤è€…éƒ½ç©ºæ‰æŠ¥é”™
    if (!imgUrl && !textPart) {
      return json({ error: "å›¾ç‰‡ URL å’Œè¯´æ˜æ–‡å­—è‡³å°‘å¡«å†™ä¸€ä¸ª" }, 400);
    }

    // åªæœ‰å¡«äº† URL æ‰æ ¡éªŒ URL
    if (imgUrl) {
      if (!isProbablyUrl(imgUrl)) return json({ error: "è¯·è¾“å…¥æœ‰æ•ˆçš„ http/https å›¾ç‰‡é“¾æ¥" }, 400);
      if (imgUrl.length > 2000) return json({ error: "é“¾æ¥å¤ªé•¿äº†" }, 400);
    }

    let output = "";
    if (textPart) output += textPart;

    if (imgUrl) {
      const imgPart = makeMdImage(imgUrl, alt || "image");
      output += (output ? "\n\n" : "") + imgPart;
    }

    return json({ url: imgUrl || "", output }, 200);
  }

  // æ–‡æœ¬æ ¼å¼åŒ–
  if (url.pathname === "/api/format" && request.method === "POST") {
    let body;
    try {
      body = await request.json();
    } catch {
      return json({ error: "è¯·æ±‚ä½“å¿…é¡»æ˜¯ JSON" }, 400);
    }

    const raw = clampLen(String(body?.raw || ""), 30000);
    const fmtMode = String(body?.fmtMode || "paragraphs");
    const paraN = String(body?.paraN || "2");
    const listN = String(body?.listN || "1");
    const listMode = String(body?.listMode || "lines");
    const emoji = clampLen(String(body?.emoji || "").trim(), 4);
    const quote = !!body?.quote;

    if (!raw.trim()) return json({ error: "è¯·ç²˜è´´è¦æ ¼å¼åŒ–çš„æ–‡å­—" }, 400);

    let formatted = "";

    if (fmtMode === "paragraphs") {
      formatted = formatIntoParagraphs(raw, paraN);
    } else if (fmtMode === "list_lines") {
      formatted = toBulletList(raw, "lines", listN);
    } else if (fmtMode === "list_sentences") {
      formatted = toBulletList(raw, "sentences", listN);
    } else if (fmtMode === "h_paragraphs") {
      formatted = renderSections(parseSections(raw), "paragraphs", paraN, listMode, listN);
    } else if (fmtMode === "h_list") {
      formatted = renderSections(parseSections(raw), "list", paraN, listMode, listN);
    } else {
      formatted = formatIntoParagraphs(raw, paraN);
    }

    // âœ… å¼ºè°ƒæ ‡è®°ï¼ˆæ›¿ä»£é¢œè‰²ï¼‰
    formatted = applyEmojiToFormattedMarkdown(formatted, emoji);

    // å¼•ç”¨å—æœ€åå†åšï¼ˆé¿å…å½±å“ emoji æ³¨å…¥åˆ¤æ–­ï¼‰
    if (quote) {
      formatted = formatted
        .split("\n")
        .map((line) => (line.trim() ? "> " + line : ">"))
        .join("\n");
    }

    return json({ formatted }, 200);
  }

  return new Response("Not Found", {
    status: 404,
    headers: { "content-type": "text/plain; charset=utf-8" },
  });
}

function json(obj, status = 200) {
  return new Response(JSON.stringify(obj), {
    status,
    headers: { "content-type": "application/json; charset=utf-8" },
  });
}
